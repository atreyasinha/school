//
// aksinha
// gpl.y
// P5: Fifth Project

// Created by Atreya Sinha on 11/26/21.
// Copyright Â© 2021 Atreya Sinha. All rights reserved.
//
// Mon Apr 27 16:03:16 PDT 2020
// bison syntax indicating C++ declarations required by both the parser and scanner
%code requires {
  #include <string>
  class Expression;
  class Variable;
  class Member_variable;
  struct Parameter;
  class Statement;
  #ifndef P1
    #include "gpl_type.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>
#include "gpl_type.h"
#include "Scope_manager.h"
#include "Expression.h"
#include "Variable.h"
#include <cassert>
#include "Constant.h"
#include "Member_variable.h"
#include "Statement.h"
#include "Event_manager.h"

template<typename BIN_OP, Operator_type optype> 
const Expression* Bin_op_check(const Expression* one, const Expression* three, unsigned int valid_types) {
    bool lhs_valid = one->type() & valid_types;
    bool rhs_valid = three->type() & valid_types;

    if (lhs_valid && rhs_valid)     return new BIN_OP(one, three);
    if (!lhs_valid)                 Error::error(Error::INVALID_LEFT_OPERAND_TYPE, operator_to_string(optype));
    if (!rhs_valid)                 Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(optype));

    delete one;
    delete three;
    return new Integer_constant(0);
}

template<typename UN_OP, Operator_type optype> 
const Expression* Un_op_check(const Expression* one, unsigned int valid_types) {
    bool valid = one->type() & valid_types;

    if (valid)                      return new UN_OP(one);
    if (!valid)                     Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(optype));

    delete one;
    return new Integer_constant(0);
}

// template<typename TER_OP, Operator_type optype> 
// const Expression* Ter_op_check(const Expression* one, const Expression* three, const Expression* five, unsigned int valid_types) {
//     bool lhs_valid = one->type() & valid_types;
//     bool rhs_valid = three->type() & valid_types;
//     bool fifth_valid = five->type() & valid_types;

//     if (lhs_valid && rhs_valid)     return new TER_OP(one, three);
//     if (!lhs_valid)                 Error::error(Error::INVALID_LEFT_OPERAND_TYPE, operator_to_string(optype));
//     if (!rhs_valid)                 Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(optype));
//     if (!five_valid)                Error::error(Error::INVALID_FIFTH_OPERAND_TYPE, operator_to_string(optype));

//     delete one;
//     delete three;
//     return new Integer_constant(0);
// }

struct Parameter {
      const Expression* expression;
      std::string name;
      Parameter* next;
      ~Parameter() { delete next; }
};

// bison syntax indicating the end of a C/C++ code section
%} 

// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int                    union_int;
 std::string*           union_string;  // MUST be a pointer to a string
 double                 union_double;
 Gpl_type               union_gpl_type;
 const Expression*      union_expression_ptr;
 Parameter*             union_parameter_ptr;
 Statement*             union_statement_ptr;
 const Variable*        union_variable_ptr;
 Window::Keystroke      union_keystroke;
};

%destructor { delete $$; } <union_string>

// tokens declared here
%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT    "exit"  /* value is line number */
%token <union_int> T_PRINT   "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"

%token T_QUESTION            "?"
%token T_COLON               ":"

%token <union_int> T_INT_CONSTANT         "int constant"
%token <union_double> T_DOUBLE_CONSTANT   "double constant"
%token <union_string> T_STRING_CONSTANT   "string constant"
%token <union_string> T_ID                "identifier"

 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"

%type <union_gpl_type> simple_type object_type

%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer

%type <union_expression_ptr> fifteen
%type <union_expression_ptr> fourteen
%type <union_expression_ptr> twelve
%type <union_expression_ptr> ten
%type <union_expression_ptr> eight
%type <union_expression_ptr> six
%type <union_expression_ptr> four
%type <union_expression_ptr> three
%type <union_expression_ptr> proto_expression

%type <union_variable_ptr> variable

%type <union_parameter_ptr> parameter
%type <union_parameter_ptr> parameter_list
%type <union_parameter_ptr> parameter_list_or_empty

%type <union_statement_ptr> statement
%type <union_statement_ptr> statement_list
%type <union_statement_ptr> statement_block
%type <union_statement_ptr> print_statement
%type <union_statement_ptr> statement_or_block_of_statements
%type <union_statement_ptr> on_block
%type <union_statement_ptr> assign_statement
%type <union_statement_ptr> assign_statement_or_empty
%type <union_keystroke> keystroke;

%type <union_statement_ptr> if_statement
%type <union_statement_ptr> for_statement
%type <union_statement_ptr> exit_statement

%nonassoc T_IF_NO_ELSE
%nonassoc T_ELSE

%%

// updated January 2019

//---------------------------------------------------------------------
program:
    declaration_list block_list
    ;

//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | empty
    ;

//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC
    ;

//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID  optional_initializer {
        Scope_manager& scopemgr = Scope_manager::instance();
        if (scopemgr.defined_in_current_scope(*$2)) {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;

            break;
        }

        try {
            if ($1 == INT) {
                int *ptr;
                if ($3 == nullptr)  ptr = new int(0);
                else                ptr = new int($3->evaluate()->as_int());
                scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
            } else if ($1 == DOUBLE) {
                double *ptr;
                if ($3 == nullptr)  ptr = new double(0.0);
                else                ptr = new double($3->evaluate()->as_double());
                scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
            } else if ($1 == STRING) {
                std::string *ptr;
                if ($3 == nullptr)  ptr = new std::string("");
                else                ptr = new std::string($3->evaluate()->as_string());
                scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
            } else                  assert(false);
            
        } catch(Gpl_type badtype) {
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(badtype), *$2, gpl_type_to_string($1));
            if ($1 == INT)              scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new int(0)));
            else if ($1 == DOUBLE)      scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new double(0.0)));
            else if ($1 == STRING)      scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new std::string("")));
            else                        assert(false);
        }

        delete $2;
        delete $3;
    }
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET {
        Scope_manager& scopemgr = Scope_manager::instance();    

        int index = 1;
        try {
            index = $4->evaluate()->as_int();
        } catch(Gpl_type badtype) {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string(badtype), *$2);
        }

        if(index < 1){
            Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string(index));
            index = 1;
        } 
        
        if (scopemgr.defined_in_current_scope(*$2)) {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            delete $4;

            break;
        }
        

        if ($1 == INT) {
            int *temp = new int[index];
            for (int i = 0; i < index; i++)    temp[i] = 0;
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == DOUBLE) {
            double *temp = new double[index];
            for (int i = 0; i < index; i++)    temp[i] = 0.0;
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == STRING) {
            std::string *temp = new std::string[index];
            for (int i = 0; i < index; i++)    temp[i] = "";
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        }
        
        delete $2;
        delete $4;
    }
    ;

//---------------------------------------------------------------------
simple_type:
    T_INT      {$$=INT;}
    | T_DOUBLE {$$=DOUBLE;}
    | T_STRING  {$$=STRING;}
    ;

//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression                                                 { $$ = $2; }
    | empty                                                             { $$ = nullptr; }
    ;

//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty {
        Scope_manager& scopemgr = Scope_manager::instance();

        if (scopemgr.defined_in_current_scope(*$2)) {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;

            break;
        }


        if ($1 == RECTANGLE) {
            Rectangle *ptr = new Rectangle();
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
            
            Parameter *cur = $3;
            while (cur != NULL) {
                try {
                    Gpl_type param_type = ptr->attribute_type(cur->name);
                    try {
                        const Constant *co = cur->expression->evaluate();
                    
                        if (param_type == INT)              ptr->write_attribute(cur->name, co->as_int());
                        else if (param_type == DOUBLE)      ptr->write_attribute(cur->name, co->as_double());
                        else if (param_type == STRING)      ptr->write_attribute(cur->name, co->as_string());
                    } catch (...) {
                        Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, cur->name);
                    }
                    
                } catch (...) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, cur->name);
                }   
                cur = cur->next;
            }
        } else if ($1 == CIRCLE) {
            Circle *ptr = new Circle();
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));

            Parameter *cur = $3;
            while (cur != NULL) {
                try {
                    Gpl_type param_type = ptr->attribute_type(cur->name);
                    try {
                        const Constant *co = cur->expression->evaluate();
                    
                        if (param_type == INT)              ptr->write_attribute(cur->name, co->as_int());
                        else if (param_type == DOUBLE)      ptr->write_attribute(cur->name, co->as_double());
                        else if (param_type == STRING)      ptr->write_attribute(cur->name, co->as_string());
                    } catch (...) {
                        Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, cur->name);
                    }
                    
                } catch (...) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, cur->name);
                }   
                cur = cur->next;
            }
        } else if ($1 == TRIANGLE) {
            Triangle *ptr = new Triangle();
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));

            Parameter *cur = $3;
            while (cur != NULL) {
                try {
                    Gpl_type param_type = ptr->attribute_type(cur->name);
                    try {
                        const Constant *co = cur->expression->evaluate();
                    
                        if (param_type == INT)              ptr->write_attribute(cur->name, co->as_int());
                        else if (param_type == DOUBLE)      ptr->write_attribute(cur->name, co->as_double());
                        else if (param_type == STRING)      ptr->write_attribute(cur->name, co->as_string());
                    } catch (...) {
                        Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, cur->name);
                    }
                    
                } catch (...) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, cur->name);
                }   
                cur = cur->next;
            }
        } else if ($1 == PIXMAP) {
            Pixmap *ptr = new Pixmap();
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));

            Parameter *cur = $3;
            while (cur != NULL) {
                try {
                    Gpl_type param_type = ptr->attribute_type(cur->name);
                    try {
                        const Constant *co = cur->expression->evaluate();
                    
                        if (param_type == INT)              ptr->write_attribute(cur->name, co->as_int());
                        else if (param_type == DOUBLE)      ptr->write_attribute(cur->name, co->as_double());
                        else if (param_type == STRING)      ptr->write_attribute(cur->name, co->as_string());
                    } catch (...) {
                        Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, cur->name);
                    }
                    
                } catch (...) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, cur->name);
                }   
                cur = cur->next;
            }
        } else if ($1 == TEXTBOX) {
            Textbox *ptr = new Textbox();
            
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));

            Parameter *cur = $3;
            while (cur != NULL) {
                try {
                    Gpl_type param_type = ptr->attribute_type(cur->name);
                    try {
                        const Constant *co = cur->expression->evaluate();
                    
                        if (param_type == INT)              ptr->write_attribute(cur->name, co->as_int());
                        else if (param_type == DOUBLE)      ptr->write_attribute(cur->name, co->as_double());
                        else if (param_type == STRING)      ptr->write_attribute(cur->name, co->as_string());
                    } catch (...) {
                        Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, cur->name);
                    }
                    
                } catch (...) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, cur->name);
                }   
                cur = cur->next;
            }
        } else                  assert(false);

    

        delete $2;
    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET {
        Scope_manager& scopemgr = Scope_manager::instance();    

        int index = 1;
        try {
            index = $4->evaluate()->as_int();
        } catch(Gpl_type badtype) {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string(badtype), *$2);
        }

        if (index < 1) {
            Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string(index));
            index = 1;
        } 
        
        if (scopemgr.defined_in_current_scope(*$2)) {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            delete $4;

            break;
        }
        

        if ($1 == RECTANGLE) {
            Rectangle* temp = new Rectangle[index];
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == CIRCLE) {
            Circle *temp = new Circle[index];
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == TRIANGLE) {
            Triangle* temp = new Triangle[index];
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == PIXMAP) {
            Pixmap* temp = new Pixmap[index];
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        } else if ($1 == TEXTBOX) {
            Textbox* temp = new Textbox[index];
            scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, temp, index));
        }
        
        delete $2;
        delete $4;
    }
    ;

//---------------------------------------------------------------------
object_type:
    T_TRIANGLE                                                          { $$ = TRIANGLE; }
    | T_PIXMAP                                                          { $$ = PIXMAP; }
    | T_CIRCLE                                                          { $$ = CIRCLE; }
    | T_RECTANGLE                                                       { $$ = RECTANGLE; }
    | T_TEXTBOX                                                         { $$ = TEXTBOX; }
    ;

//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN                                    { $$ = $2; }
    | T_LPAREN empty T_RPAREN                                           { $$ = NULL; }
    | empty                                                             { $$ = NULL; }
    ;

//---------------------------------------------------------------------
parameter_list :
    parameter T_COMMA parameter_list {
        Parameter* cur = $1;
        while (cur->next != NULL)           cur = cur->next;
        cur->next = $3;
        $1 = cur->next;
    }
    | parameter                                                         { $$ = $1; } 
    ;

//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression                                            { $$ = new Parameter{$3, *$1, NULL}; }
    ;

//---------------------------------------------------------------------
block_list:
    block_list block
    | empty
    ;

//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block
    ;

//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block
    ;

//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block
    ;

//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN    
    ;

//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID
    | object_type
    ;

//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block                               
    ;

//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN
    ;

//----------------------------------------------this-----------------------
on_block:
    T_ON keystroke statement_block {
        Event_manager& e = Event_manager::instance();
        e.add_handler($2, $3);
    }
    ;

//---------------------------------------------------------------------
keystroke:
    T_SPACE                                                         { $$ = Window::Keystroke::SPACE; }
    | T_UPARROW                                                     { $$ = Window::Keystroke::UPARROW; }
    | T_DOWNARROW                                                   { $$ = Window::Keystroke::DOWNARROW; }
    | T_LEFTARROW                                                   { $$ = Window::Keystroke::LEFTARROW; }
    | T_RIGHTARROW                                                  { $$ = Window::Keystroke::RIGHTARROW; }
    | T_LEFTMOUSE_DOWN                                              { $$ = Window::Keystroke::LEFTMOUSE_DOWN; }
    | T_MIDDLEMOUSE_DOWN                                            { $$ = Window::Keystroke::MIDDLEMOUSE_DOWN; }
    | T_RIGHTMOUSE_DOWN                                             { $$ = Window::Keystroke::RIGHTMOUSE_DOWN; }
    | T_LEFTMOUSE_UP                                                { $$ = Window::Keystroke::LEFTMOUSE_UP; }
    | T_MIDDLEMOUSE_UP                                              { $$ = Window::Keystroke::MIDDLEMOUSE_UP; }
    | T_RIGHTMOUSE_UP                                               { $$ = Window::Keystroke::RIGHTMOUSE_UP; }
    | T_MOUSE_MOVE                                                  { $$ = Window::Keystroke::MOUSE_MOVE; }
    | T_MOUSE_DRAG                                                  { $$ = Window::Keystroke::MOUSE_DRAG; }
    | T_AKEY                                                        { $$ = Window::Keystroke::AKEY; }
    | T_SKEY                                                        { $$ = Window::Keystroke::SKEY; }
    | T_DKEY                                                        { $$ = Window::Keystroke::DKEY; }
    | T_FKEY                                                        { $$ = Window::Keystroke::FKEY; }
    | T_HKEY                                                        { $$ = Window::Keystroke::HKEY; }
    | T_JKEY                                                        { $$ = Window::Keystroke::JKEY; }
    | T_KKEY                                                        { $$ = Window::Keystroke::KKEY; }
    | T_LKEY                                                        { $$ = Window::Keystroke::LKEY; }
    | T_WKEY                                                        { $$ = Window::Keystroke::WKEY; }
    | T_F1                                                          { $$ = Window::Keystroke::F1; }
    ;

//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block                                                 { $$ = $1; }
    | statement                                                     { $$ = $1; }
    ;

//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE                                { $$ = $2; }
    | T_LBRACE T_RBRACE                                             { $$ = new NullStatement(); }
    ;


//---------------------------------------------------------------------
statement_list:
    statement statement_list                                        { $1->append_statement($2); $$ = $1; }
    | statement                                                     { $$ = $1; }
    ;

//---------------------------------------------------------------------
statement:
    if_statement                                                    { $$ = $1; }
    | for_statement                                                 { $$ = $1; }
    | assign_statement T_SEMIC                                      { $$ = $1; }
    | print_statement T_SEMIC                                       { $$ = $1; }
    | exit_statement T_SEMIC                                        { $$ = $1; }
    ;

//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec T_IF_NO_ELSE {
        if ($3->type() == INT)      $$ = new If($3, $5, NULL);
        else {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
            $$ = nullptr;
        }
    }
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements {
        if ($3->type() == INT)      $$ = new If($3, $5, $7);
        else {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
            $$ = nullptr;
        }
    }
    ;

//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements {
        if ($5->type() == INT)      $$ = new For($3, $5, $7, $9);
        else {
            Error::error(Error::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION);
            $$ = nullptr;
        }
    }
    ;

//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN { 
        if ($3->type() & (INT|DOUBLE|STRING))       $$ = new Print($1, $3); 
        else                                        Error::error(Error::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
    }
    ;

//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN {
        if ($3->type() & (INT))                                     $$ = new Exit($1, $3);                           
        else {
            Error::error(Error::EXIT_STATUS_MUST_BE_AN_INTEGER, gpl_type_to_string($3->type()));
            $$ = nullptr;
        }  
    }
    ;

//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement                                                { $$ = $1; }
    | empty                                                         { $$ = new NullStatement(); }
    ;

//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression { 
        if ($1->type() < $3->type()) {
            Error::error(Error::ASSIGNMENT_TYPE_ERROR, gpl_type_to_string($1->type()), gpl_type_to_string($3->type()));
        }                                
        else if ($1->type() & (INT|DOUBLE|STRING|ANIMATION_BLOCK))  $$ = new Assign($1, $3); 
        else {
            Error::error(Error::INVALID_LHS_OF_ASSIGNMENT, $1->name(), gpl_type_to_string($1->type()));
        }                        
    }
    | variable T_PLUS_ASSIGN expression {   
        if ($1->type() < $3->type()) {
            Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string($1->type()), gpl_type_to_string($3->type()));
        }                                
        else if ($1->type() & (INT|DOUBLE|STRING))                  $$ = new Plus_assign($1, $3); 
        else {
            Error::error(Error::INVALID_LHS_OF_PLUS_ASSIGNMENT, $1->name(), gpl_type_to_string($1->type()));
        }    
    }
    | variable T_MINUS_ASSIGN expression { 
        if (($1->type() & (INT|DOUBLE) && !($3->type() & (INT|DOUBLE))) || ($1->type() == INT && $3->type() == DOUBLE) ) {
            Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string($1->type()), gpl_type_to_string($3->type()));
        }                                
        else if ($1->type() & (INT|DOUBLE))                         $$ = new Minus_assign($1, $3); 
        else {
            Error::error(Error::INVALID_LHS_OF_MINUS_ASSIGNMENT, $1->name(), gpl_type_to_string($1->type()));
        }   
    }
    | variable T_PLUS_PLUS { 
        if ($1->type() & (INT))                                     $$ = new Plus_plus($1);                           
        else {
            Error::error(Error::INVALID_LHS_OF_PLUS_PLUS, $1->name(), gpl_type_to_string($1->type()));
            $$ = nullptr;
        }   
    }
    | variable T_MINUS_MINUS { 
        if ($1->type() & (INT))                                     $$ = new Minus_minus($1);                           
        else {
            Error::error(Error::INVALID_LHS_OF_MINUS_MINUS, $1->name(), gpl_type_to_string($1->type()));
            $$ = nullptr;
        }   
    }
    ;

//---------------------------------------------------------------------
variable:
    T_ID {
        Scope_manager& scopemgr = Scope_manager::instance();
        std::shared_ptr<Symbol> sb = scopemgr.lookup(*$1);

        if (sb == NULL) {
            $$ = new Variable("");
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            delete $1;
            break;
        }

        if (sb->is_array()) {
            $$ = new Variable("");
            Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
            delete $1;
            break;
        }

        $$ = new Variable(*$1);
        delete $1;
    }                                                       
    | T_ID T_LBRACKET expression T_RBRACKET {
        Scope_manager& scopemgr = Scope_manager::instance();
        std::shared_ptr<Symbol> sb = scopemgr.lookup(*$1);

        if (sb == NULL) {
            Error::error(Error::UNDECLARED_VARIABLE, *$1 + "[]");
        } else if (!sb->is_array()){
            Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
        } else if ($3->type() != INT){
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()));
        } else {
            $$ = new Variable(*$1, $3);
            delete $1;
            break;
        }

        $$ = new Variable("");
        delete $1;
        delete $3;
    }                      
    | T_ID T_PERIOD T_ID {
        Scope_manager& scopemgr = Scope_manager::instance();
        std::shared_ptr<Symbol> sb = scopemgr.lookup(*$1);

        if (sb == NULL) {
            $$ = new Variable("");
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            delete $1;
            delete $3;
            break;
        } else if (sb->is_array()) {
            $$ = new Variable("");
            Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
            delete $1;
            delete $3;
            break;
        } else {
            try { 
                std::shared_ptr<const Constant>(sb->as_constant(*$3)); 
            } catch (const Gpl_type badtype) {
                $$ = new Variable("");
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                delete $1;
                delete $3;
                break;
            } catch(const std::out_of_range &) {
                $$ = new Variable("");
                Error::error(Error::UNDECLARED_MEMBER, *$1, *$3);
                delete $1;
                delete $3;
                break;
            }
            $$ = new Member_variable(*$1, *$3);
        }

        delete $1;
    }    
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
        Scope_manager& scopemgr = Scope_manager::instance();
        std::shared_ptr<Symbol> sb = scopemgr.lookup(*$1);

        if (sb == NULL) {
            $$ = new Variable("");
            Error::error(Error::UNDECLARED_VARIABLE, *$1 + "[]");
            delete $1;
            delete $3;
            delete $6;
            break;
        } else if (!sb->is_array()) {
            $$ = new Variable("");
            Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
            delete $1;
            delete $3;
            delete $6;
            break;
        } else if ($3->type() != INT) {
            $$ = new Variable("");
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()));
            delete $1;
            delete $3;
            delete $6;
            break;
        } else {
            try { 
                std::shared_ptr<const Constant>(sb->as_constant(*$6)); 
            } catch (const Gpl_type badtype) {
                $$ = new Variable("");
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                delete $1;
                delete $6;
                break;
            } catch(const std::out_of_range &) {
                $$ = new Variable("");
                Error::error(Error::UNDECLARED_MEMBER, *$1, *$6);
                delete $1;
                delete $6;
                break;
            }
            $$ = new Member_variable(*$1, $3, *$6);
        }

        delete $1;
    }  
    ;

//---------------------------------------------------------------------
expression:
    fifteen
    ;

fifteen:
    fourteen
        | expression T_OR fourteen                                  { $$ = Bin_op_check<Or, OR>($1, $3, INT|DOUBLE ); }
        ;

fourteen:
    twelve
        | fourteen T_AND twelve                                     { $$ = Bin_op_check<And, AND>($1, $3, INT|DOUBLE ); }
        ;

twelve:
    ten
        | twelve T_EQUAL ten                                        { $$ = Bin_op_check<Equal, EQUAL>($1, $3, INT|DOUBLE|STRING ); }
        | twelve T_NOT_EQUAL ten                                    { $$ = Bin_op_check<Not_Equal, NOT_EQUAL>($1, $3, INT|DOUBLE|STRING ); }
        ;

ten:
    eight
        | ten T_LESS eight                                          { $$ = Bin_op_check<Less_Than, LESS_THAN>($1, $3, INT|DOUBLE|STRING ); }
        | ten T_GREATER  eight                                      { $$ = Bin_op_check<Greater_Than, GREATER_THAN>($1, $3, INT|DOUBLE|STRING ); }
        | ten T_LESS_EQUAL eight                                    { $$ = Bin_op_check<Less_Equal, LESS_EQUAL>($1, $3, INT|DOUBLE|STRING ); }
        | ten T_GREATER_EQUAL  eight                                { $$ = Bin_op_check<Greater_Equal, GREATER_EQUAL>($1, $3, INT|DOUBLE|STRING ); }
        // | ten T_QUESTION  eight                                     { $$ = Ter_op_check<Question, QUESTION>($1, $3, INT|DOUBLE, INT|DOUBLE|STRING ); }
        // | ten T_COLON  eight                                        { $$ = Ter_op_check<Colon, COLON>($1, $3, INT|DOUBLE, INT|DOUBLE|STRING ); }
        ;

eight:
    six
        | eight T_PLUS six                                          { $$ = Bin_op_check<Plus, PLUS>($1, $3, INT|DOUBLE|STRING ); }
        | eight T_MINUS six                                         { $$ = Bin_op_check<Minus, MINUS>($1, $3, INT|DOUBLE ); }
        ;

six:
    four
        | six T_MULTIPLY four                                       { $$ = Bin_op_check<Multiply, MULTIPLY>($1, $3, INT|DOUBLE ); }
        | six T_DIVIDE four                                         { 
            if (($3->type() & (INT|DOUBLE) ) && ($3->evaluate()->as_double() == 0 )) {
                Error::error(Error::DIVIDE_BY_ZERO_AT_PARSE_TIME);
                delete $3;
                delete $1;
                $$ = new Integer_constant(0);
            } else $$ = Bin_op_check<Divide, DIVIDE>($1, $3, INT|DOUBLE );
        }
        | six T_MOD four                                            { 
            if (($3->type() & (INT)) && ($3->evaluate()->as_int() == 0 )) {
                Error::error(Error::MOD_BY_ZERO_AT_PARSE_TIME);
                delete $3;
                delete $1;
                $$ = new Integer_constant(0);
            } else $$ = Bin_op_check<Mod, MOD>($1, $3, INT );
        }
        ;

four:
    three
        | T_NOT  four                                               { $$ = Un_op_check<Not, NOT>($2, INT|DOUBLE ); }
        | T_MINUS  four                                             { $$ = Un_op_check<Unary_minus, UNARY_MINUS>($2, INT|DOUBLE ); }
        ;

three:
    proto_expression
        | three T_TOUCHES proto_expression                          { $$ = nullptr; /*CHANGE*/ }
        | three T_NEAR proto_expression                             { $$ = nullptr; /*CHANGE*/ }
        ;

proto_expression:
        primary_expression                                          { $$=$1; }
        | T_SIN T_LPAREN expression T_RPAREN                        { $$ = Un_op_check<Sine, SIN>($3, INT|DOUBLE ); }
        | T_COS T_LPAREN expression T_RPAREN                        { $$ = Un_op_check<Cosine, COS>($3, INT|DOUBLE ); }
        | T_TAN T_LPAREN expression T_RPAREN                        { $$ = Un_op_check<Tan, TAN>($3, INT|DOUBLE ); }
        | T_ASIN T_LPAREN expression T_RPAREN                       { $$ = Un_op_check<Asin, ASIN>($3, INT|DOUBLE ); }
        | T_ACOS T_LPAREN expression T_RPAREN                       { $$ = Un_op_check<Acos, ACOS>($3, INT|DOUBLE ); }
        | T_ATAN T_LPAREN expression T_RPAREN                       { $$ = Un_op_check<Atan, ATAN>($3, INT|DOUBLE ); }
        | T_SQRT T_LPAREN expression T_RPAREN                       { $$ = Un_op_check<Sqrt, SQRT>($3, INT|DOUBLE ); }
        | T_ABS T_LPAREN expression T_RPAREN                        { $$ = Un_op_check<Abs, ABS>($3, INT|DOUBLE ); }
        | T_FLOOR T_LPAREN expression T_RPAREN                      { $$ = Un_op_check<Floor, FLOOR>($3, INT|DOUBLE ); }
        | T_RANDOM T_LPAREN expression T_RPAREN                     { $$ = Un_op_check<Random, RANDOM>($3, INT|DOUBLE ); }
        ;

//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN                                   { $$ = $2; }
    | variable                                                      { $$ = $1; }
    | T_INT_CONSTANT                                                { $$ = new Integer_constant($1); }
    | T_TRUE                                                        { $$ = new Integer_constant(1); }
    | T_FALSE                                                       { $$ = new Integer_constant(0); }
    | T_DOUBLE_CONSTANT                                             { $$ = new Double_constant($1); }
    | T_STRING_CONSTANT                                             { $$ = new String_constant(*$1); delete $1; }
    ;

//---------------------------------------------------------------------
empty:
    // empty goes to nothing so that you can use empty in productions
    // when you want a production to go to nothing
    ;
%%